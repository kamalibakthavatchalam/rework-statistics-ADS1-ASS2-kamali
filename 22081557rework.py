# -*- coding: utf-8 -*-
"""Resubmission.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jkqzME_T_FrhNKHbMjgyDRhrBqJKWozy
"""

# Import important libraries for data manipulation and visualization
import pandas as pd  # Pandas for handling and analyzing tabular data (Reading CSV file and data prococessing)
import matplotlib.pyplot as plt  # Matplotlib for basic data visualization
import seaborn as sns  # Seaborn for enhanced data visualization
import scipy.stats as stats  # Scipy for statistical analysis functions
import numpy as np  # Mathematical function
from scipy.stats import norm

def read_data(filename):
    """
    Read data from a CSV file, perform necessary transformations (Dropping Irrelevant Columns)

    Parameters:
    - filename (str): The path to the CSV file containing the data.

    Returns:
    - data (pd.DataFrame): A cleaned DataFrame
    """

    # Read the data from the file into a DataFrame, skipping unnecessary initial columns
    data = pd.read_csv(filename, skiprows=4).iloc[:, :-1]

    # Drop unnecessary columns: Country Code, Indicator Name, Indicator Code
    data.drop(['Country Code', 'Indicator Code'], axis=1, inplace=True)

    #Fill missing values
    data.fillna(0, inplace=True)


    return data

def get_indicator_data(data, indicator):
    """
    Extract data for a specific indicator from the given DataFrame
    and perform necessary transformations.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data.
    - indicator (str): The name of the indicator to extract.

    Returns:
    - indicator_data (pd.DataFrame): DataFrame containing data for the specified indicator.
    - filtered_data_t (pd.DataFrame): Transposed and cleaned DataFrame with numeric index and 'Years' column.

    """
    # Filter data for the specified indicator
    indicator_data = data[data['Indicator Name'] == indicator]

    # Drop unnecessary column Indicator Name
    indicator_data.drop(['Indicator Name'], axis=1, inplace=True)

    # Transpose the DataFrame
    filtered_data_t = indicator_data.transpose()

    # Set the first row as column names
    filtered_data_t.columns = filtered_data_t.iloc[0]

    # Exclude the first row
    filtered_data_t = filtered_data_t.iloc[1:]

    # Convert the index to numeric values
    filtered_data_t.index = pd.to_numeric(filtered_data_t.index)

    # Create a 'Years' column with index values
    filtered_data_t['Years'] = filtered_data_t.index

    # Reset the index in place
    filtered_data_t.reset_index(drop=True, inplace=True)

    return indicator_data, filtered_data_t

def extract_data(data, indicators, countries):
    """
    Extracts and filters data based on specified indicators and countries. Return two dataframes

    Parameters:
    - data (pd.DataFrame): The input DataFrame containing the data.
    - indicators (list): List of indicator names to include in the filtered data.
    - countries (list): List of country names to include in the filtered data.

    Returns:
    - years_df (pd.DataFrame): A DataFrame containing the filtered data with years as columns
    - countries_df (pd.DataFrame): A DataFrame containing the filtered data with years as rows
    """

    # Filter data based on specified indicators and countries
    filtered_data = data[(data["Indicator Name"].isin(indicators)) & (data["Country Name"].isin(countries))]

    years_to_keep = [str(year) for year in range(1995, 2021)]
    filtered_data = filtered_data[['Country Name', 'Indicator Name'] + years_to_keep]


    return filtered_data

def plot_bar(data, y_label, title, years):
    """
    Create a bar plot to compare countries for given years

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data.
    - y_label (str): The label for the y-axis.
    - title (str): The title of the bar plot.
    - years (list): List of years to include in the plot.

    Returns:
    None
    """

    df_filtered = data[data['Years'].isin(years)]

    # Extracting the list of countries from the DataFrame columns
    countries = df_filtered.columns[0:-1]  # Exclude 'Years' from the list

    # Create the bar plot
    sns.set_palette("husl")
    plt.figure(figsize=(6, 4))
    df_filtered.plot(x='Years', y= countries, kind='bar', xlabel='Years', ylabel=y_label)

    plt.title(title)

    # Customize legend position
    plt.legend(loc='upper left', bbox_to_anchor=(1, 1))

    plt.savefig('barplot.png')
    plt.show()

def plot_line(data, y_label, title):
    """
    Creates a line plot for countries over the years using a DataFrame.

    Parameters:
    - data (pd.DataFrame): The input DataFrame containing country-wise data over the years.
    - y_label (str): The label for the y-axis .
    - title (str): The title of the line plot.

    Returns:
    None

    """

    # Extracting the list of countries from the DataFrame columns
    countries = data.columns[0:-1]  # Exclude 'Years' from the list

    # Creating the line plot for all countries
    plt.figure(figsize=(6, 4))
    data.plot(x='Years', y=countries, xlabel='Years', ylabel=y_label, marker='.', style= '--')

    plt.title(title)
    plt.legend( bbox_to_anchor=(1, 1), loc='upper left')
    plt.savefig('lineplot.png')
    plt.show()

def plot_box(data, y_label, title):
    """
    Create a box plot for all countries in the dataset and saved as 'boxplot.png'.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data.
    - y_label (str): The label for the y-axis .
    - title (str): The title of the line plot.

    Returns:
    None

    """

    # Exclude the last column ('Years')
    data = data.iloc[:, :-1]

    plt.figure(figsize=(12, 6))
    sns.boxplot(data=data)

    plt.title(title, fontsize=20)
    plt.xlabel('Country Name')
    plt.ylabel(y_label)
    plt.xticks(rotation=45,fontsize=14)
    plt.savefig('boxplot.png')
    plt.show()

def plot_bars_all_years(data, y_label, title):
    """
    Create a bar plot to compare countries for all years

    Parameters:
    - df (pd.DataFrame): The DataFrame containing the data.
    - y_label (str): The label for the y-axis.
    - title (str): The title of the bar plot.

    Returns:
    None
    """

    # Exclude the last column (presumably 'Years')
    data = data.iloc[:, :-1]

    plt.figure(figsize=(6, 4))
    sns.barplot(data=data)
    plt.title(title)
    plt.xlabel('Country Name')
    plt.ylabel(y_label)
    plt.xticks(rotation=45)
    plt.savefig('plotallbars.png')
    plt.show()

def plot_strippedline(df, y_label, title, kind):
    """
    Create a stripped plot for multiple countries over the years using the provided DataFrame and saved as 'dotplot.png'

    Parameters:
    - df (pd.DataFrame): The DataFrame containing the data.
    - y_label (str): The label for the y-axis .
    - title (str): The title of the dot plot.

    Returns:
    None

    """
    plt.figure(figsize=(6, 4))
    sns.set_style("whitegrid")

    # Melt the DataFrame for a tidy format suitable for dot plot
    melted_df = df.melt(id_vars=['Years'], var_name='Country', value_name='Value')

    dot = sns.catplot(x='Years', y='Value', hue='Country', data=melted_df, kind=kind)
    dot.set_xticklabels(rotation=90)

    # Set 5-year gaps in x ticks
    ax = dot.axes[0, 0]
    xmin, xmax = int(ax.get_xlim()[0]), int(ax.get_xlim()[1])
    ax.set_xlim(xmin, xmax)
    ax.set_xticks(range(xmin, xmax+1, 5))
    ax.set_xticklabels(range(1995, 2021, 5))

    plt.title(title)
    plt.ylabel(y_label)
    plt.savefig('strippedplot.png')
    plt.show()

def create_correlation_heatmap(data, year):
    """
    Create a correlation heatmap to visualize relationships between indicators for a specific year.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data.
    - year (str): The specific year for which to create the correlation heatmap.

    Returns:
    None

    """
    # Filter data for the specific year
    year_data = data[['Country Name', 'Indicator Name', year]]

    # Pivot the DataFrame for a heatmap
    heatmap_data = year_data.pivot_table(index='Indicator Name', columns='Country Name', values=year)

    # Define a dictionary to map original indicator names to desired names
    indicator_name_mapping = {
        'Urban population (% of total population)':'Urban population',
        'Population, total':'Total Population',
        'CO2 emissions (kt)':'CO2 emissions',
        'Renewable energy consumption (% of total final energy consumption)':'Renewable energy consumption',
        'Forest area (% of land area)':'Forest area',
        'Access to electricity (% of population)':'Access to electricity'
    }

    # Rename the columns using the mapping
    heatmap_data = heatmap_data.rename(index=indicator_name_mapping)

    # Calculate correlations between indicators
    correlation_matrix = heatmap_data.T.corr()

    plt.figure(figsize=(6, 4))
    sns.heatmap(correlation_matrix, annot=True, cmap="viridis", linewidths=.5, fmt = ".2f")

    plt.title(f'Correlation Heatmap ({year})')
    plt.savefig('heatmap.png')
    plt.show()



def plot_piechart(data, title, year):
    """
    Create piechart for a specific year.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data.
    -title (str): Title for pie chart
    - year (str): The specific year


    Returns:
    None

    """

    plt.figure(figsize=(6,6))
    plt.pie(data[str(year)],
            labels=data['Country Name'],autopct='%1.1f%%', startangle=180
           )
    plt.title(title)
    plt.savefig('piechart.png')
    plt.show()

def bootstrap(dist, function, confidence_level=0.90, nboot=10000):
    """ Carries out a bootstrap of dist to get the uncertainty of statistical
    function applied to it.
    -Dist can be a numpy array or a pandas dataseries.
    -confidence_level specifies the quantile (defaulted to 0.90). E.g 0.90
    means the quantile from 0.05 to 0.95 is evaluated.
    -nboot (default 10000) is the number of bootstraps to be evaluated.

    Returns the lower and upper quantiles.
    A call of the form
    low, high = bootstrap(dist, np.mean, confidence_level=0.682)
    will return the lower and upper limits of the 1 sigma range
    """

    fvalues = np.array([]) # creates an empty array to store function values
    dlen = len(dist)
    for i in range(nboot):
        rand = np.random.choice(dist, dlen, replace=True)
        f = function(rand)
        fvalues = np.append(fvalues, f)

    # lower and upper quantiles
    qlow = 0.5 - confidence_level/2.0
    qhigh = 0.5 + confidence_level/2.0

    low = np.quantile(fvalues, qlow)
    high = np.quantile(fvalues, qhigh)

    return low, high

def get_statistics(data, title):
    """
    This function get statistics of data of specific country for specific indicator
    and calculate skewness, kurtosis, mean, std_deviation, bootstrap and also plot histogram with probabilty
    density function.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the data of specific country for specific indicator.
    -title (str): Title for pie chart



    Returns:
    None

    """

    data = pd.to_numeric(data, errors='coerce')
    data.dropna(inplace=True)
    skewness = stats.skew(data)
    kurtosis = stats.kurtosis(data)
    mean = np.mean(data)
    std_dev = np.std(data)
    minimum = np.min(data)
    maximum = np.max(data)

    print("skewness\t", np.round(skewness, 6))
    print("kurtosis\t", np.round(kurtosis, 6))
    print("Mean\t", np.round(mean, 6))
    print("Std\t", np.round(std_dev, 6))
    print("Minimum\t", np.round(minimum, 6))
    print("Maximum\t", np.round(maximum, 6))

    # Call the boostrap routine with statistical functions
    low, high = bootstrap(data, np.mean, confidence_level=0.682)
    sigma = 0.5 * (high - low)
    print("average = ", np.round(mean, 4), "+/-", np.round(sigma, 6),
          " significance level ", np.round(np.abs(mean/sigma), 3))

    low, high = bootstrap(data, np.std, confidence_level=0.682)
    sigma = 0.5 * (high - low)
    print("std. dev = ", np.round(std_dev, 4), "+/-", np.round(sigma, 6),
          " significance level", np.round(np.abs(std_dev/sigma), 3))

    low, high = bootstrap(data, stats.skew, confidence_level=0.682)
    sigma = 0.5 * (high - low)
    print("skewness = ", np.round(skewness, 4), "+/-", np.round(sigma, 6),
          " significance level ", np.round(np.abs(skewness/sigma), 3))

    low, high = bootstrap(data, stats.kurtosis, confidence_level=0.682)
    sigma = 0.5 * (high - low)
    print("kurtosis = ", np.round(kurtosis, 4), "+/-", np.round(sigma, 6),
          " significance level ", np.round(np.abs(kurtosis/sigma), 3))

    plt.figure(figsize=(8, 6))

    # Plotting the histogram with probability density function
    plt.hist(data, bins=20, density=True, alpha=0.5, color='blue')

    # Adding a probability density function (PDF) curve
    xmin, xmax = plt.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = norm.pdf(x, np.mean(data), np.std(data))
    plt.plot(x, p, 'k', linewidth=2)

    plt.grid(True)

    plt.title(title)
    legend_text = f"Mean={mean:.2f}\nStd={std_dev:.2f}\nSkewness={skewness:.2f}\nKurtosis={kurtosis:.2f}"
    # Get the Axes object
    ax = plt.gca()

    # Add text to the legend
    legend = ax.legend(["PDF", "Histogram"], loc='upper right', bbox_to_anchor=(1, 1))
    ax.add_artist(legend)
    ax.text(1.02, 0.9, legend_text, transform=ax.transAxes, fontsize=10, verticalalignment='top')

    plt.xlabel("Data")
    plt.ylabel('Probability Density')
    #plt.legend(["PDF", "Histogram", legend_text])

    plt.savefig('histplot_with_pdf.png')
    plt.show()

"""## **Main Function**"""

#Main Function
#Read csv file
data = read_data("API_19_DS2_en_csv_v2_6300757.csv")

# Select specific Asian countries and indicators for analysis.
countries = ['China', 'India', 'Japan', 'Indonesia', 'Pakistan']

# Specific Indicators
indicators = ['Urban population (% of total population)',
              'Population, total',
              'CO2 emissions (kt)',
              'Renewable energy consumption (% of total final energy consumption)',
              'Forest area (% of land area)',
              'Access to electricity (% of population)'
              ]

#extract data for selected Asian countries and indicators
data = extract_data(data, indicators, countries)

#Data Description and Statistics
data.head()
data.info()

data.describe()

#to find correlation among indicators heatmap is generated
create_correlation_heatmap(data, '2020')

#create two separate dataframes for each indicators

co2_indicator = 'CO2 emissions (kt)'
co2_df, co2_df_t = get_indicator_data(data, co2_indicator)

urban_indicator = 'Urban population (% of total population)'
urban_df, urban_df_t = get_indicator_data(data, urban_indicator)

acc_elc_indicator = 'Access to electricity (% of population)'
acc_elc_df, acc_elc_df_t = get_indicator_data(data, acc_elc_indicator)

rnw_cnsmp_indicator = 'Renewable energy consumption (% of total final energy consumption)'
rnw_cnsmp_df, rnw_cnsmp_df_t = get_indicator_data(data, rnw_cnsmp_indicator)

forest_indicator = 'Forest area (% of land area)'
forest_df, forest_df_t = get_indicator_data(data, forest_indicator)

pop_indicator = 'Population, total'
pop_df, pop_df_t = get_indicator_data(data, pop_indicator)

#plot line for C02 Emission
plot_line(co2_df_t, 'kt', 'CO2 Emission')
plot_line(acc_elc_df_t, '%', 'Access to Electricity')

#plot bars for specific years
years =  [1995, 2000, 2005, 2010, 2015, 2020]
plot_bar(pop_df_t, 'Population\n', 'Total Population', years )

plot_box(rnw_cnsmp_df_t, '(%)', 'Renewable Energy Consumption')

plot_bar(rnw_cnsmp_df_t, '(%)\n', 'Renewable Energy Consumption', years )

# Bar plot for Urban population
plot_bars_all_years(urban_df_t, '(%)','Urban Population\n(% of Total Population)')

plot_bars_all_years(acc_elc_df_t, '(%)','Access to Electricity\n(% of Total Population)')

filtered_data = acc_elc_df_t[acc_elc_df_t['Years']==2020]
plot_bars_all_years(filtered_data, '(%)','Access to Electricity(2020)\n(% of Total Population)')

plot_strippedline(forest_df_t, '(%)', 'Forest Area', 'strip')

plot_piechart(acc_elc_df, 'Access to Electricity (%)\n(2020)', 2020)
plot_piechart(acc_elc_df, 'Access to Electricity (%)\n(2000)', 2000)

plot_piechart(urban_df, 'Urban Population (%)\n(1995)', 1995)

plot_strippedline(acc_elc_df_t, '(%)', 'Access to Electricity', 'point')

plot_strippedline(urban_df_t, '(%)', 'Urban Population', 'point')

get_statistics(co2_df_t['China'], "China C02 Emission")

get_statistics(co2_df_t['Pakistan'], "Pakistan C02 Emission")

get_statistics(rnw_cnsmp_df_t['Pakistan'], "Pakistan Renewable Energy Consumption")